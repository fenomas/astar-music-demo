{"version":3,"file":"index-Dq-DmDWO.js","sources":["../../node_modules/.pnpm/solid-js@1.9.3/node_modules/solid-js/dist/solid.js","../../node_modules/.pnpm/solid-js@1.9.3/node_modules/solid-js/web/dist/web.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/lib/contextCache.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/builders/sourceNodes.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/builders/shapers.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/builders/crusher.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/builders/filters.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/builders/effects.js","../../node_modules/.pnpm/param-enveloper@0.3.0/node_modules/param-enveloper/src/index.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/lib/params.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/lib/sources.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/soundPlayer.js","../../node_modules/.pnpm/wasgen@0.18.4/node_modules/wasgen/src/index.js","../../node_modules/.pnpm/ts-priority-queue@0.1.1/node_modules/ts-priority-queue/src/BinaryHeapStrategy.js","../../node_modules/.pnpm/ts-priority-queue@0.1.1/node_modules/ts-priority-queue/src/PriorityQueue.js","../../node_modules/.pnpm/ts-priority-queue@0.1.1/node_modules/ts-priority-queue/index.js","../../node_modules/.pnpm/abstract-pathfinder@https+++codeload.github.com+fenomas+abstract-pathfinder+tar.gz+49c7d53d4f_u2a2m2c6pozupthj44nirfjuiy/node_modules/abstract-pathfinder/dist/index.js","../../src/music/instruments.ts","../../src/music/util.ts","../../src/music/music.ts","../../src/music/Main.tsx","../../src/index.tsx"],"sourcesContent":["let taskIdCounter = 1,\n  isCallbackScheduled = false,\n  isPerformingWork = false,\n  taskQueue = [],\n  currentTask = null,\n  shouldYieldToHost = null,\n  yieldInterval = 5,\n  deadline = 0,\n  maxYieldInterval = 300,\n  scheduleCallback = null,\n  scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n    port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = (n + m) >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;\n      else if (cmp < 0) n = k - 1;\n      else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n    timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {\n  context: undefined,\n  registry: undefined,\n  effects: undefined,\n  done: false,\n  getContextId() {\n    return getContextId(this.context.count);\n  },\n  getNextContextId() {\n    return getContextId(this.context.count++);\n  }\n};\nfunction getContextId(count) {\n  const num = String(count),\n    len = num.length - 1;\n  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : \"\") + num;\n}\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return {\n    ...sharedConfig.context,\n    id: sharedConfig.getNextContextId(),\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst SUPPORTS_PROXY = typeof Proxy === \"function\";\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    current = detachedOwner === undefined ? owner : detachedOwner,\n    root = unowned\n      ? UNOWNED\n      : {\n          owned: null,\n          cleanups: null,\n          context: current ? current.context : null,\n          owner: current\n        },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);\n      else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  if (!options || !options.render) c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(\n      () => {\n        fn ? fn() : untrack(onInvalidate);\n        fn = undefined;\n      },\n      undefined,\n      false,\n      0\n    ),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if ((arguments.length === 2 && typeof pFetcher === \"object\") || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null,\n    initP = NO_INIT,\n    id = null,\n    loadedUnderTransition = false,\n    scheduled = false,\n    resolved = \"initialValue\" in options,\n    dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n    [value, setValue] = (options.storage || createSignal)(options.initialValue),\n    [error, setError] = createSignal(undefined),\n    [track, trigger] = createSignal(undefined, {\n      equals: false\n    }),\n    [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = sharedConfig.getNextContextId();\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;\n    else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      key !== undefined && (resolved = true);\n      if ((p === initP || v === initP) && options.onHydrated)\n        queueMicrotask(() =>\n          options.onHydrated(key, {\n            value: v\n          })\n        );\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === undefined) setValue(() => v);\n      setState(err !== undefined ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && useContext(SuspenseContext),\n      v = value(),\n      err = error();\n    if (err !== undefined && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);\n          else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p =\n      initP !== NO_INIT\n        ? initP\n        : untrack(() =>\n            fetcher(lookup, {\n              value: value(),\n              refetching\n            })\n          );\n    if (!isPromise(p)) {\n      loadEnd(pr, p, undefined, lookup);\n      return p;\n    }\n    pr = p;\n    if (\"value\" in p) {\n      if (p.status === \"success\") loadEnd(pr, p.value, undefined, lookup);\n      else loadEnd(pr, undefined, castError(p.value), lookup);\n      return p;\n    }\n    scheduled = true;\n    queueMicrotask(() => (scheduled = false));\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(\n      v => loadEnd(p, v, undefined, lookup),\n      e => loadEnd(p, undefined, castError(e), lookup)\n    );\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));\n  else load(false);\n  return [\n    read,\n    {\n      refetch: load,\n      mutate: setValue\n    }\n  ];\n}\nfunction createDeferred(source, options) {\n  let t,\n    timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(\n    () => {\n      if (!t || !t.fn)\n        t = requestCallback(\n          () => setDeferred(() => node.value),\n          timeout !== undefined\n            ? {\n                timeout\n              }\n            : undefined\n        );\n      return source();\n    },\n    undefined,\n    true\n  );\n  const [deferred, setDeferred] = createSignal(\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    options\n  );\n  updateComputation(node);\n  setDeferred(() =>\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n  );\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(\n    p => {\n      const v = source();\n      for (const [key, val] of subs.entries())\n        if (fn(key, v) !== fn(key, p)) {\n          for (const c of val.values()) {\n            c.state = STALE;\n            if (c.pure) Updates.push(c);\n            else Effects.push(c);\n          }\n        }\n      return v;\n    },\n    undefined,\n    true,\n    STALE\n  );\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if ((l = subs.get(key))) l.add(listener);\n      else subs.set(key, (l = new Set([listener])));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(\n      key,\n      Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n    );\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (!ExternalSourceConfig && Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return prevValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null);\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction catchError(fn, handler) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  Owner = createComputation(undefined, undefined, true);\n  Owner.context = {\n    ...Owner.context,\n    [ERROR]: [handler]\n  };\n  if (Transition && Transition.running) Transition.sources.add(Owner);\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = Owner.owner;\n  }\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t =\n        Transition ||\n        (Transition = {\n          sources: new Set(),\n          effects: [],\n          promises: new Set(),\n          disposed: new Set(),\n          queue: new Set(),\n          running: true\n        });\n      t.done || (t.done = new Promise(res => (t.resolve = res)));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nconst [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let value;\n  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined\n    ? value\n    : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext());\n}\nfunction enableExternalSource(factory, untrack = fn => fn()) {\n  if (ExternalSourceConfig) {\n    const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;\n    ExternalSourceConfig = {\n      factory: (fn, trigger) => {\n        const oldSource = oldFactory(fn, trigger);\n        const source = factory(x => oldSource.track(x), trigger);\n        return {\n          track: x => source.track(x),\n          dispose() {\n            source.dispose();\n            oldSource.dispose();\n          }\n        };\n      },\n      untrack: fn => oldUntrack(() => untrack(fn))\n    };\n  } else {\n    ExternalSourceConfig = {\n      factory,\n      untrack\n    };\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (runningTransition ? this.tState : this.state)) {\n    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current =\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || (!isComp && Transition.sources.has(node))) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);\n            else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;\n          else o.tState = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (false);\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(\n    node,\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    time\n  );\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner,\n    listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      if (Transition && Transition.running) {\n        node.tState = STALE;\n        node.tOwned && node.tOwned.forEach(cleanNode);\n        node.tOwned = undefined;\n      } else {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null);\n  else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];\n      else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];\n      else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceConfig && c.fn) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if ((runningTransition ? node.tState : node.state) === 0) return;\n  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (runningTransition ? node.tState : node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n        prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if ((runningTransition ? node.tState : node.state) === STALE) {\n      updateComputation(node);\n    } else if ((runningTransition ? node.tState : node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);\n    else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);\n    else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) {\n    if (sharedConfig.count) {\n      sharedConfig.effects || (sharedConfig.effects = []);\n      sharedConfig.effects.push(...queue.slice(0, userLength));\n      return;\n    }\n    setHydrateContext();\n  }\n  if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {\n    queue = [...sharedConfig.effects, ...queue];\n    userLength += sharedConfig.effects.length;\n    delete sharedConfig.effects;\n  }\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;\n  else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = runningTransition ? source.tState : source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))\n          runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (runningTransition ? !o.tState : !o.state) {\n      if (runningTransition) o.tState = PENDING;\n      else o.state = PENDING;\n      if (o.pure) Updates.push(o);\n      else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (node.tOwned) {\n    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n    delete node.tOwned;\n  }\n  if (Transition && Transition.running && node.pure) {\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;\n  else node.state = 0;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction runErrors(err, fns, owner) {\n  try {\n    for (const f of fns) f(err);\n  } catch (e) {\n    handleError(e, (owner && owner.owner) || null);\n  }\n}\nfunction handleError(err, owner = Owner) {\n  const fns = ERROR && owner && owner.context && owner.context[ERROR];\n  const error = castError(err);\n  if (!fns) throw error;\n  if (Effects)\n    Effects.push({\n      fn() {\n        runErrors(error, fns, owner);\n      },\n      state: STALE\n    });\n  else runErrors(error, fns, owner);\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(\n      () =>\n        (res = untrack(() => {\n          Owner.context = {\n            ...Owner.context,\n            [id]: props.value\n          };\n          return children(() => props.children);\n        })),\n      undefined\n    );\n    return res;\n  };\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null);\n  else if (Owner.context === null || !Owner.context[ERROR]) {\n    Owner.context = {\n      ...Owner.context,\n      [ERROR]: [fn]\n    };\n    mutateContext(Owner, ERROR, [fn]);\n  } else Owner.context[ERROR].push(fn);\n}\nfunction mutateContext(o, key, value) {\n  if (o.owned) {\n    for (let i = 0; i < o.owned.length; i++) {\n      if (o.owned[i].context === o.context) mutateContext(o.owned[i], key, value);\n      if (!o.owned[i].context) {\n        o.owned[i].context = o.context;\n        mutateContext(o.owned[i], key, value);\n      } else if (!o.owned[i].context[key]) {\n        o.owned[i].context[key] = value;\n        mutateContext(o.owned[i], key, value);\n      }\n    }\n  }\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler =\n        typeof observer === \"function\" ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => (\"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub()));\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      newLen = newItems.length,\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (\n          start = 0, end = Math.min(len, newLen);\n          start < end && items[start] === newItems[start];\n          start++\n        );\n        for (\n          end = len - 1, newEnd = newLen - 1;\n          end >= start && newEnd >= start && items[end] === newItems[newEnd];\n          end--, newEnd--\n        ) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, (len = newLen));\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [],\n      newLen = newItems.length;\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newLen; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newLen;\n      items = newItems.slice(0);\n      return (mapped = mapped.slice(0, len));\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction resolveSources() {\n  for (let i = 0, length = this.length; i < length; ++i) {\n    const v = this[i]();\n    if (v !== undefined) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || (!!s && $PROXY in s);\n    sources[i] = typeof s === \"function\" ? ((proxy = true), createMemo(s)) : s;\n  }\n  if (SUPPORTS_PROXY && proxy) {\n    return new Proxy(\n      {\n        get(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            const v = resolveSource(sources[i])[property];\n            if (v !== undefined) return v;\n          }\n        },\n        has(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            if (property in resolveSource(sources[i])) return true;\n          }\n          return false;\n        },\n        keys() {\n          const keys = [];\n          for (let i = 0; i < sources.length; i++)\n            keys.push(...Object.keys(resolveSource(sources[i])));\n          return [...new Set(keys)];\n        }\n      },\n      propTraps\n    );\n  }\n  const sourcesMap = {};\n  const defined = Object.create(null);\n  for (let i = sources.length - 1; i >= 0; i--) {\n    const source = sources[i];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i = sourceKeys.length - 1; i >= 0; i--) {\n      const key = sourceKeys[i];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get\n          ? {\n              enumerable: true,\n              configurable: true,\n              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))\n            }\n          : desc.value !== undefined\n          ? desc\n          : undefined;\n      } else {\n        const sources = sourcesMap[key];\n        if (sources) {\n          if (desc.get) sources.push(desc.get.bind(source));\n          else if (desc.value !== undefined) sources.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i = definedKeys.length - 1; i >= 0; i--) {\n    const key = definedKeys[i],\n      desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : undefined;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if (SUPPORTS_PROXY && $PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map(k => {\n      return new Proxy(\n        {\n          get(property) {\n            return k.includes(property) ? props[property] : undefined;\n          },\n          has(property) {\n            return k.includes(property) && property in props;\n          },\n          keys() {\n            return k.filter(property => property in props);\n          }\n        },\n        propTraps\n      );\n    });\n    res.push(\n      new Proxy(\n        {\n          get(property) {\n            return blocked.has(property) ? undefined : props[property];\n          },\n          has(property) {\n            return blocked.has(property) ? false : property in props;\n          },\n          keys() {\n            return Object.keys(props).filter(k => !blocked.has(k));\n          }\n        },\n        propTraps\n      )\n    );\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc =\n      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc\n          ? (objects[objectIndex][propName] = desc.value)\n          : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc\n        ? (otherObject[propName] = desc.value)\n        : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      sharedConfig.count || (sharedConfig.count = 0);\n      sharedConfig.count++;\n      (p || (p = fn())).then(mod => {\n        !sharedConfig.done && setHydrateContext(ctx);\n        sharedConfig.count--;\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    }\n    let Comp;\n    return createMemo(() =>\n      (Comp = comp())\n        ? untrack(() => {\n            if (false);\n            if (!ctx || sharedConfig.done) return Comp(props);\n            const c = sharedConfig.context;\n            setHydrateContext(ctx);\n            const r = Comp(props);\n            setHydrateContext(c);\n            return r;\n          })\n        : \"\"\n    );\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => (comp = () => mod.default)), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? sharedConfig.getNextContextId() : `cl-${counter++}`;\n}\n\nconst narrowedError = name => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => (keyed ? a === b : !a === !b)\n  });\n  return createMemo(\n    () => {\n      const c = condition();\n      if (c) {\n        const child = props.children;\n        const fn = typeof child === \"function\" && child.length > 0;\n        return fn\n          ? untrack(() =>\n              child(\n                keyed\n                  ? c\n                  : () => {\n                      if (!untrack(condition)) throw narrowedError(\"Show\");\n                      return props.when;\n                    }\n              )\n            )\n          : child;\n      }\n      return props.fallback;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Switch(props) {\n  let keyed = false;\n  const equals = (a, b) => (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];\n  const conditions = children(() => props.children),\n    evalConditions = createMemo(\n      () => {\n        let conds = conditions();\n        if (!Array.isArray(conds)) conds = [conds];\n        for (let i = 0; i < conds.length; i++) {\n          const c = conds[i].when;\n          if (c) {\n            keyed = !!conds[i].keyed;\n            return [i, c, conds[i]];\n          }\n        }\n        return [-1];\n      },\n      undefined,\n      {\n        equals\n      }\n    );\n  return createMemo(\n    () => {\n      const [index, when, cond] = evalConditions();\n      if (index < 0) return props.fallback;\n      const c = cond.children;\n      const fn = typeof c === \"function\" && c.length > 0;\n      return fn\n        ? untrack(() =>\n            c(\n              keyed\n                ? when\n                : () => {\n                    if (untrack(evalConditions)[0] !== index) throw narrowedError(\"Match\");\n                    return cond.when;\n                  }\n            )\n          )\n        : c;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  if (sharedConfig.context && sharedConfig.load)\n    err = sharedConfig.load(sharedConfig.getContextId());\n  const [errored, setErrored] = createSignal(err, undefined);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(\n    () => {\n      let e;\n      if ((e = errored())) {\n        const f = props.fallback;\n        return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n      }\n      return catchError(() => props.children, setErrored);\n    },\n    undefined,\n    undefined\n  );\n}\n\nconst suspenseListEquals = (a, b) =>\n  a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = /* #__PURE__ */ createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n      inFallback: false\n    })),\n    show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(\n    prev => {\n      const reveal = props.revealOrder,\n        tail = props.tail,\n        { showContent = true, showFallback = true } = show ? show() : {},\n        reg = registry(),\n        reverse = reveal === \"backwards\";\n      if (reveal === \"together\") {\n        const all = reg.every(inFallback => !inFallback());\n        const res = reg.map(() => ({\n          showContent: all && showContent,\n          showFallback\n        }));\n        res.inFallback = !all;\n        return res;\n      }\n      let stop = false;\n      let inFallback = prev.inFallback;\n      const res = [];\n      for (let i = 0, len = reg.length; i < len; i++) {\n        const n = reverse ? len - i - 1 : i,\n          s = reg[n]();\n        if (!stop && !s) {\n          res[n] = {\n            showContent,\n            showFallback\n          };\n        } else {\n          const next = !stop;\n          if (next) inFallback = true;\n          res[n] = {\n            showContent: next,\n            showFallback: !tail || (next && tail === \"collapsed\") ? showFallback : false\n          };\n          stop = true;\n        }\n      }\n      if (!stop) inFallback = false;\n      res.inFallback = inFallback;\n      return res;\n    },\n    {\n      inFallback: false\n    }\n  );\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n    show,\n    ctx,\n    p,\n    flicker,\n    error;\n  const [inFallback, setFallback] = createSignal(false),\n    SuspenseContext = getSuspenseContext(),\n    store = {\n      increment: () => {\n        if (++counter === 1) setFallback(true);\n      },\n      decrement: () => {\n        if (--counter === 0) setFallback(false);\n      },\n      inFallback,\n      effects: [],\n      resolved: false\n    },\n    owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.getContextId();\n    let ref = sharedConfig.load(key);\n    if (ref) {\n      if (typeof ref !== \"object\" || ref.status !== \"success\") p = ref;\n      else sharedConfig.gather(key);\n    }\n    if (p && p !== \"$$f\") {\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(\n        () => {\n          if (sharedConfig.done) return set();\n          sharedConfig.gather(key);\n          setHydrateContext(ctx);\n          set();\n          setHydrateContext();\n        },\n        err => {\n          error = err;\n          set();\n        }\n      );\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return (flicker = undefined);\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n            { showContent = true, showFallback = true } = show ? show() : {};\n          if ((!inFallback || (p && p !== \"$$f\")) && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"F\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nconst DEV = undefined;\n\nexport {\n  $DEVCOMP,\n  $PROXY,\n  $TRACK,\n  DEV,\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  Show,\n  Suspense,\n  SuspenseList,\n  Switch,\n  batch,\n  cancelCallback,\n  catchError,\n  children,\n  createComponent,\n  createComputed,\n  createContext,\n  createDeferred,\n  createEffect,\n  createMemo,\n  createReaction,\n  createRenderEffect,\n  createResource,\n  createRoot,\n  createSelector,\n  createSignal,\n  createUniqueId,\n  enableExternalSource,\n  enableHydration,\n  enableScheduling,\n  equalFn,\n  from,\n  getListener,\n  getOwner,\n  indexArray,\n  lazy,\n  mapArray,\n  mergeProps,\n  observable,\n  on,\n  onCleanup,\n  onError,\n  onMount,\n  requestCallback,\n  resetErrorBoundaries,\n  runWithOwner,\n  sharedConfig,\n  splitProps,\n  startTransition,\n  untrack,\n  useContext,\n  useTransition\n};\n","import {\n  createRoot,\n  createRenderEffect,\n  untrack,\n  sharedConfig,\n  enableHydration,\n  getOwner,\n  createEffect,\n  runWithOwner,\n  createMemo,\n  createSignal,\n  onCleanup,\n  splitProps\n} from \"solid-js\";\nexport {\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  Show,\n  Suspense,\n  SuspenseList,\n  Switch,\n  createComponent,\n  createRenderEffect as effect,\n  getOwner,\n  createMemo as memo,\n  mergeProps,\n  untrack\n} from \"solid-js\";\n\nconst booleans = [\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"indeterminate\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"seamless\",\n  \"selected\"\n];\nconst Properties = /*#__PURE__*/ new Set([\n  \"className\",\n  \"value\",\n  \"readOnly\",\n  \"formNoValidate\",\n  \"isMap\",\n  \"noModule\",\n  \"playsInline\",\n  ...booleans\n]);\nconst ChildProperties = /*#__PURE__*/ new Set([\n  \"innerHTML\",\n  \"textContent\",\n  \"innerText\",\n  \"children\"\n]);\nconst Aliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  class: \"className\",\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a = PropAliases[prop];\n  return typeof a === \"object\" ? (a[tagName] ? a[\"$\"] : undefined) : a;\n}\nconst DelegatedEvents = /*#__PURE__*/ new Set([\n  \"beforeinput\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"focusin\",\n  \"focusout\",\n  \"input\",\n  \"keydown\",\n  \"keyup\",\n  \"mousedown\",\n  \"mousemove\",\n  \"mouseout\",\n  \"mouseover\",\n  \"mouseup\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerout\",\n  \"pointerover\",\n  \"pointerup\",\n  \"touchend\",\n  \"touchmove\",\n  \"touchstart\"\n]);\nconst SVGElements = /*#__PURE__*/ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/ new Set([\n  \"html\",\n  \"base\",\n  \"head\",\n  \"link\",\n  \"meta\",\n  \"style\",\n  \"title\",\n  \"body\",\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"footer\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"section\",\n  \"body\",\n  \"blockquote\",\n  \"dd\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"figcaption\",\n  \"figure\",\n  \"hr\",\n  \"li\",\n  \"ol\",\n  \"p\",\n  \"pre\",\n  \"ul\",\n  \"a\",\n  \"abbr\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"br\",\n  \"cite\",\n  \"code\",\n  \"data\",\n  \"dfn\",\n  \"em\",\n  \"i\",\n  \"kbd\",\n  \"mark\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"small\",\n  \"span\",\n  \"strong\",\n  \"sub\",\n  \"sup\",\n  \"time\",\n  \"u\",\n  \"var\",\n  \"wbr\",\n  \"area\",\n  \"audio\",\n  \"img\",\n  \"map\",\n  \"track\",\n  \"video\",\n  \"embed\",\n  \"iframe\",\n  \"object\",\n  \"param\",\n  \"picture\",\n  \"portal\",\n  \"source\",\n  \"svg\",\n  \"math\",\n  \"canvas\",\n  \"noscript\",\n  \"script\",\n  \"del\",\n  \"ins\",\n  \"caption\",\n  \"col\",\n  \"colgroup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"tr\",\n  \"button\",\n  \"datalist\",\n  \"fieldset\",\n  \"form\",\n  \"input\",\n  \"label\",\n  \"legend\",\n  \"meter\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"progress\",\n  \"select\",\n  \"textarea\",\n  \"details\",\n  \"dialog\",\n  \"menu\",\n  \"summary\",\n  \"details\",\n  \"slot\",\n  \"template\",\n  \"acronym\",\n  \"applet\",\n  \"basefont\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"center\",\n  \"content\",\n  \"dir\",\n  \"font\",\n  \"frame\",\n  \"frameset\",\n  \"hgroup\",\n  \"image\",\n  \"keygen\",\n  \"marquee\",\n  \"menuitem\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"plaintext\",\n  \"rb\",\n  \"rtc\",\n  \"shadow\",\n  \"spacer\",\n  \"strike\",\n  \"tt\",\n  \"xmp\",\n  \"a\",\n  \"abbr\",\n  \"acronym\",\n  \"address\",\n  \"applet\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"basefont\",\n  \"bdi\",\n  \"bdo\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"center\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"content\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"font\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"image\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"marquee\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"plaintext\",\n  \"portal\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"shadow\",\n  \"slot\",\n  \"small\",\n  \"source\",\n  \"spacer\",\n  \"span\",\n  \"strike\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"tt\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  \"xmp\",\n  \"input\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\"\n]);\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? (bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart]) : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document\n      ? code()\n      : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, isImportNode, isSVG) {\n  let node;\n  const create = () => {\n    const t = document.createElement(\"template\");\n    t.innerHTML = html;\n    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;\n  };\n  const fn = isImportNode\n    ? () => untrack(() => document.importNode(node || (node = create()), true))\n    : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setProperty(node, name, value) {\n  if (isHydrating(node)) return;\n  node[name] = value;\n}\nfunction setAttribute(node, name, value) {\n  if (isHydrating(node)) return;\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (isHydrating(node)) return;\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction setBoolAttribute(node, name, value) {\n  if (isHydrating(node)) return;\n  value ? node.setAttribute(name, \"\") : node.removeAttribute(name);\n}\nfunction className(node, value) {\n  if (isHydrating(node)) return;\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, (handler[0] = e => handlerFn.call(node, handler[1], e)));\n  } else node.addEventListener(name, handler, typeof handler !== \"function\" && handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n    prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n      classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return (nodeStyle.cssText = value);\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    createRenderEffect(\n      () => (prevProps.children = insertExpression(node, props.children, prevProps.children))\n    );\n  }\n  createRenderEffect(() => typeof props.ref === \"function\" && use(props.ref, node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  if (globalThis._$HY.done) return render(code, element, [...element.childNodes], options);\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = id => globalThis._$HY.r[id];\n  sharedConfig.has = id => id in globalThis._$HY.r;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  try {\n    gatherHydratable(element, options.renderId);\n    return render(code, element, [...element.childNodes], options);\n  } finally {\n    sharedConfig.context = null;\n  }\n}\nfunction getNextElement(template) {\n  let node,\n    key,\n    hydrating = isHydrating();\n  if (!hydrating || !(node = sharedConfig.registry.get((key = getHydrationKey())))) {\n    return template();\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n    count = 0,\n    current = [];\n  if (isHydrating(start)) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"$\") count++;\n        else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const { completed, events } = sharedConfig;\n      if (!events) return;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        events.shift();\n        eventHandler(e);\n      }\n      if (sharedConfig.done) {\n        sharedConfig.events = _$HY.events = null;\n        sharedConfig.completed = _$HY.completed = null;\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction isHydrating(node) {\n  return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)\n    node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef, props) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev, typeof prev !== \"function\" && prev);\n    value && node.addEventListener(e, value, typeof value !== \"function\" && value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (prop.slice(0, 5) === \"bool:\") {\n    setBoolAttribute(node, prop.slice(5), value);\n  } else if (\n    (forceProp = prop.slice(0, 5) === \"prop:\") ||\n    (isChildProp = ChildProperties.has(prop)) ||\n    (!isSVG &&\n      ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop)))) ||\n    (isCE = node.nodeName.includes(\"-\") || \"is\" in props)\n  ) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    } else if (isHydrating(node)) return value;\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  if (sharedConfig.registry && sharedConfig.events) {\n    if (sharedConfig.events.find(([el, ev]) => ev === e)) return;\n  }\n  let node = e.target;\n  const key = `$$${e.type}`;\n  const oriTarget = e.target;\n  const oriCurrentTarget = e.currentTarget;\n  const retarget = value =>\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value\n    });\n  const handleNode = () => {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node.host &&\n      typeof node.host !== \"string\" &&\n      !node.host._$host &&\n      node.contains(e.target) &&\n      retarget(node.host);\n    return true;\n  };\n  const walkUpTree = () => {\n    while (handleNode() && (node = node._$host || node.parentNode || node.host));\n  };\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;\n  if (e.composedPath) {\n    const path = e.composedPath();\n    retarget(path[0]);\n    for (let i = 0; i < path.length - 2; i++) {\n      node = path[i];\n      if (!handleNode()) break;\n      if (node._$host) {\n        node = node._$host;\n        walkUpTree();\n        break;\n      }\n      if (node.parentNode === oriCurrentTarget) {\n        break;\n      }\n    }\n  } else walkUpTree();\n  retarget(oriTarget);\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  const hydrating = isHydrating(parent);\n  if (hydrating) {\n    !current && (current = [...parent.childNodes]);\n    let cleaned = [];\n    for (let i = 0; i < current.length; i++) {\n      const node = current[i];\n      if (node.nodeType === 8 && node.data.slice(0, 2) === \"!$\") node.remove();\n      else cleaned.push(node);\n    }\n    current = cleaned;\n  }\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = (multi && current[0] && current[0].parentNode) || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (hydrating) return current;\n    if (t === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (hydrating) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => (current = insertExpression(parent, array, current, marker, true)));\n      return () => current;\n    }\n    if (hydrating) {\n      if (!array.length) return current;\n      if (marker === undefined) return (current = [...parent.childNodes]);\n      let node = array[0];\n      if (node.parentNode !== parent) return current;\n      const nodes = [node];\n      while ((node = node.nextSibling) !== marker) nodes.push(node);\n      return (current = nodes);\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (hydrating && value.parentNode) return (current = multi ? [value] : value);\n    if (Array.isArray(current)) {\n      if (multi) return (current = cleanChildren(parent, current, marker, value));\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[normalized.length],\n      t;\n    if (item == null || item === true || item === false);\n    else if ((t = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic =\n          normalizeIncomingArray(\n            normalized,\n            Array.isArray(item) ? item : [item],\n            Array.isArray(prev) ? prev : [prev]\n          ) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return (parent.textContent = \"\");\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i)\n          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key))\n      sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  return sharedConfig.getNextContextId();\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\nfunction Hydration(props) {\n  return props.children;\n}\nconst voidFn = () => undefined;\nconst RequestContext = Symbol();\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction ssrElement(name, props, children, needsId) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction resolveSSRNode(node) {}\nfunction escape(html) {}\nfunction ssrSpread(props, isSVG, skipChildren) {}\n\nconst isServer = false;\nconst isDev = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const { useShadow } = props,\n    marker = document.createTextNode(\"\"),\n    mount = () => props.mount || document.body,\n    owner = getOwner();\n  let content;\n  let hydrating = !!sharedConfig.context;\n  createEffect(\n    () => {\n      if (hydrating) getOwner().user = hydrating = false;\n      content || (content = runWithOwner(owner, () => createMemo(() => props.children)));\n      const el = mount();\n      if (el instanceof HTMLHeadElement) {\n        const [clean, setClean] = createSignal(false);\n        const cleanup = () => setClean(true);\n        createRoot(dispose => insert(el, () => (!clean() ? content() : dispose()), null));\n        onCleanup(cleanup);\n      } else {\n        const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot =\n            useShadow && container.attachShadow\n              ? container.attachShadow({\n                  mode: \"open\"\n                })\n              : container;\n        Object.defineProperty(container, \"_$host\", {\n          get() {\n            return marker.parentNode;\n          },\n          configurable: true\n        });\n        insert(renderRoot, content);\n        el.appendChild(container);\n        props.ref && props.ref(container);\n        onCleanup(() => el.removeChild(container));\n      }\n    },\n    undefined,\n    {\n      render: !hydrating\n    }\n  );\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p.component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport {\n  Aliases,\n  voidFn as Assets,\n  ChildProperties,\n  DOMElements,\n  DelegatedEvents,\n  Dynamic,\n  Hydration,\n  voidFn as HydrationScript,\n  NoHydration,\n  Portal,\n  Properties,\n  RequestContext,\n  SVGElements,\n  SVGNamespace,\n  addEventListener,\n  assign,\n  classList,\n  className,\n  clearDelegatedEvents,\n  delegateEvents,\n  dynamicProperty,\n  escape,\n  voidFn as generateHydrationScript,\n  voidFn as getAssets,\n  getHydrationKey,\n  getNextElement,\n  getNextMarker,\n  getNextMatch,\n  getPropAlias,\n  voidFn as getRequestEvent,\n  hydrate,\n  innerHTML,\n  insert,\n  isDev,\n  isServer,\n  render,\n  renderToStream,\n  renderToString,\n  renderToStringAsync,\n  resolveSSRNode,\n  runHydrationEvents,\n  setAttribute,\n  setAttributeNS,\n  setBoolAttribute,\n  setProperty,\n  spread,\n  ssr,\n  ssrAttribute,\n  ssrClassList,\n  ssrElement,\n  ssrHydrationKey,\n  ssrSpread,\n  ssrStyle,\n  style,\n  template,\n  use,\n  voidFn as useAssets\n};\n","\n\n/*\n * \n *      a per-AudioContext cache object for each module to store things\n * \n*/\n\nvar caches = new Map()\n\nexport function getCache(ctx) {\n    if (!caches.has(ctx)) {\n        caches.set(ctx, {})\n    }\n    return caches.get(ctx)\n}\n\n// not needed, since per-context settings need to persist even if Gen is disposed\n// export function clearCache(ctx) {\n//     caches.delete(ctx)\n// }\n\n","\nimport { getCache } from '../lib/contextCache'\n\n\n/*\n * \n * \n *      Creates bare WebAudio nodes that deliver a source signal\n * \n * \n*/\n\nexport function isNoise(type) {\n    return (/^n/i.test(type))\n}\n\nexport function createSourceNode(ctx, type) {\n    // disamiguates type and defers to implementations below\n    type = type.toLowerCase()\n    var node\n    if (type[0] === 'w') node = createWave(ctx, type)\n    if (type[0] === 'p') node = createPulse(ctx, type)\n    if (type[0] === 'n') node = createNoise(ctx, type)\n    if (!node) node = createOscillator(ctx, type)\n    return node\n}\n\n\n\n\n\n\n\n\n\n/*\n * \n *      OSCILLATORS\n * \n*/\n\n\nfunction createOscillator(ctx, type) {\n    var osc = ctx.createOscillator()\n    osc.type = (type[0] === 't') ? 'triangle' :\n        oscillatorTypes[type.substr(0, 2)] || 'sine'\n    return osc\n}\n\nvar oscillatorTypes = {\n    si: 'sine',\n    sq: 'square',\n    sa: 'sawtooth',\n    tr: 'triangle',\n}\n\n\n\n\n\n/*\n * \n *      PULSES\n * \n *      converts 'p25' into a 25% duty pulse wave, etc\n *      ref: https://github.com/pendragon-andyh/WebAudio-PulseOscillator\n*/\n\nfunction createPulse(ctx, type) {\n    var duty = Math.round(parseInt(type.substr(1)) || 50)\n    duty = Math.min(Math.max(duty, 1), 99)\n    var osc = ctx.createOscillator()\n    osc.type = 'sawtooth'\n    var shaper = ctx.createWaveShaper()\n    shaper.curve = makePulseCurve(duty)\n    osc.connect(shaper)\n    // return a fake wrapper that looks like an oscillator\n    return {\n        start: t => osc.start(t),\n        frequency: osc.frequency,\n        connect: node => shaper.connect(node),\n        disconnect: () => {\n            // treat as dispose\n            shaper.disconnect()\n            osc.disconnect()\n            osc.stop()\n        },\n        input: osc,\n    }\n}\n\nfunction makePulseCurve(duty) {\n    var N = 256\n    if (curves[duty]) return curves[duty]\n    var curve = new Float32Array(N)\n    var cutoff = N * duty / 100\n    for (var i = 0; i < N; i++) {\n        curve[i] = (i < cutoff) ? 1 : -1\n    }\n    return curves[duty] = curve\n}\nvar curves = {}\n\n\n\n\n/*\n * \n *      WAVES\n * \n *      converts 'w90909', 'w9753211', etc. into a (cached) periodicWave\n * \n*/\n\nfunction createWave(ctx, type) {\n    var osc = ctx.createOscillator()\n    if (type.length < 2) type += '9'\n    osc.setPeriodicWave(getPeriodicWave(ctx, type))\n    return osc\n}\n\nfunction getPeriodicWave(ctx, name) {\n    var data = getCache(ctx)\n    if (!data.periodicWaves) data.periodicWaves = {}\n    var cachedWaves = data.periodicWaves\n\n    if (!cachedWaves[name]) {\n        var imag = new Float32Array(name.length)\n        var real = new Float32Array(name.length)\n        for (var i = 1; i < name.length; ++i) {\n            var num = parseFloat(name[i]) / 9\n            imag[i] = num * num\n        }\n        cachedWaves[name] = ctx.createPeriodicWave(real, imag)\n    }\n    return cachedWaves[name]\n}\n\n\n\n\n\n\n/*\n * \n *      NOISE\n * \n *      values are:\n *          'n0'  white (default)\n *          'np'  pink\n *          'nb'  brown\n *          'n1'  metallic\n * \n*/\n\nfunction createNoise(ctx, type) {\n    var data = getCache(ctx)\n    if (!data.noiseBuffers) data.noiseBuffers = {}\n    var cachedNoise = data.noiseBuffers\n\n    var src = ctx.createBufferSource()\n    var noiseType = noiseTypes[type] || 'n0'\n    if (!cachedNoise[noiseType]) {\n        cachedNoise[noiseType] = createNoiseBuffer(ctx, noiseType)\n    }\n    src.buffer = cachedNoise[noiseType]\n    src.loop = true\n    return src\n}\nvar noiseTypes = {\n    n0: 'n0',\n    n1: 'n1',\n    np: 'np',\n    nb: 'nb',\n}\n\n\n\n\nfunction createNoiseBuffer(ctx, type) {\n    var noiseLen = {\n        n0: 1,\n        n1: 1.5,\n        nb: 1.5,\n        np: 1.5,\n    }[type] // seconds\n    var blen = (noiseLen * ctx.sampleRate) | 0\n    var buffer = ctx.createBuffer(1, blen, ctx.sampleRate)\n    var data = buffer.getChannelData(0)\n    if (type === 'n0') makeWhiteNoise(data)\n    if (type === 'nb') makeBrownNoise(data)\n    if (type === 'np') makePinkNoise(data)\n    if (type === 'n1') makeMetallicNoise(data)\n    return buffer\n}\n\nfunction makeWhiteNoise(data) {\n    for (var i = 0; i < data.length; i++) {\n        data[i] = 2 * Math.random() - 1\n    }\n}\n\nfunction makePinkNoise(data) {\n    // Paul Kellet's algorithm, from:\n    // http://www.firstpr.com.au/dsp/pink-noise/\n    var b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0\n    var max = 0\n    data.forEach((v, i) => {\n        var white = 2 * Math.random() - 1\n        b0 = 0.99886 * b0 + white * 0.0555179\n        b1 = 0.99332 * b1 + white * 0.0750759\n        b2 = 0.96900 * b2 + white * 0.1538520\n        b3 = 0.86650 * b3 + white * 0.3104856\n        b4 = 0.55000 * b4 + white * 0.5329522\n        b5 = -0.7616 * b5 - white * 0.0168980\n        data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362\n        b6 = white * 0.115926\n        max = Math.max(max, Math.abs(data[i]))\n    })\n    data.forEach((v, i) => { data[i] /= max })\n}\n\nfunction makeBrownNoise(data) {\n    var a = 0, max = 0\n    for (var i = 0; i < data.length; i++) {\n        var white = 2 * Math.random() - 1\n        a = (a + white * 0.02) / 1.02\n        max = Math.max(max, Math.abs(a))\n        data[i] = a\n    }\n    data.forEach((v, i) => { data[i] /= max })\n}\n\nfunction makeMetallicNoise(data) {\n    // pseudorandom harmonics of 440hz\n    var n = hash(1)\n    var max = 0\n    for (var j = 0; j < 24; j++) {\n        n = hash(n)\n        var a = 1 + (j % 16)\n        var b = 2 + (n * 10)\n        var peak = addHarmonics(data, a, b, 1 / 4)\n        max = Math.max(max, peak)\n    }\n    data.forEach((v, i) => { data[i] /= max })\n}\n\n\n\n\n\n\n// helpers\n\nvar addHarmonics = (data, r1, r2, scale) => {\n    var max = 0\n    var posScale = 2 * Math.PI * 440 / 44100\n    var phase1 = Math.random() * 2 * Math.PI\n    var phase2 = Math.random() * 2 * Math.PI\n    for (var i = 0; i < data.length; i++) {\n        var pos = i * posScale\n        var a = fastSin(phase1 + r1 * pos)\n        var b = fastSin(phase2 + r2 * pos)\n        data[i] += a * b * scale\n        max = Math.max(max, Math.abs(data[i]))\n    }\n    return max\n}\n\nfunction hash(n) {\n    n = (n + Math.sqrt(17)) * Math.sqrt(23)\n    return n - Math.floor(n)\n}\n\nvar fastSin = (() => {\n    var lookups = []\n    var mult = 512 / (2 * Math.PI)\n    for (var i = 0; i < 512; i++) lookups[i] = Math.sin(i / mult)\n    // this version assumes (t >= 0) !!!\n    return (t) => lookups[(t * mult) & 511]\n})()\n","\n\n/*\n * \n *      Creates a web audio node for wave-shaper distortion\n * \n*/\n\n\n// tells whether given type corresponds to a shaper node\nexport function isShaper(type) {\n    return (/^shape/i.test(type))\n}\n\n\n\n// create a shaper node based on the input signal definition\nexport function createShaper(ctx, type) {\n    // distortion type\n    var arr = type.split('-')\n    var curveType = arr[1]\n    var numArg = parseFloat(arr[2])\n    if (isNaN(numArg)) numArg = 5\n    if (!curveCreators[curveType]) {\n        console.warn('unknown curve type: ' + curveType)\n        curveType = 'linear'\n        numArg = 5\n    }\n\n    // shaper curve array\n    var cachekey = curveType + '-' + numArg\n    if (!curveCache[cachekey]) {\n        curveCache[cachekey] = curveCreators[curveType](numArg)\n    }\n    var curve = curveCache[cachekey]\n\n    // shaper node\n    var shaper = ctx.createWaveShaper()\n    shaper.curve = curve\n    return shaper\n}\n\n\n\n\n\n// wave shaper curve creation / cache\nvar curveCache = {}\nvar curveCreators = {}\n\n\n\n\n\ncurveCreators.linear = (num) => {\n    // fallback, no distortion\n    return new Float32Array([-1, 1])\n}\n\ncurveCreators.clip = (num) => {\n    var v = num / 10\n    return new Float32Array([-v, -v, 0, v, v])\n}\n\ncurveCreators.tanh = (num) => {\n    var scale = 0.5 * clamp(1, num, 40)\n    var N = 255\n    var arr = new Float32Array(N)\n    for (var i = 0; i < arr.length; i++) {\n        var x = 2 * (i / (N - 1)) - 1\n        arr[i] = Math.tanh(x * scale)\n    }\n    return arr\n}\n\n\ncurveCreators.boost = (num) => {\n    var ct = Math.ceil(num / 2)\n    var arr = new Float32Array(2 * ct + 1)\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = (i < ct) ? -1 :\n            (i === ct) ? 0 : 1\n    }\n    return arr\n}\n\ncurveCreators.fold = (num) => {\n    var v = num / 10\n    return new Float32Array([0, -v, 0, v, 0])\n}\n\n\ncurveCreators.crush = (depth) => {\n    depth = clamp(1, depth, 40)\n    var steps = depth\n    var N = 255\n    var arr = new Float32Array(N)\n    for (var i = 0; i < N; i++) {\n        var x = 2 * (i / (N - 1)) - 1\n        arr[i] = Math.round(x * (steps + 0.4999)) / steps\n        if (Math.abs(arr[i]) < 0.001) arr[i] = 0\n    }\n    return arr\n}\n\n\n\ncurveCreators.thin = (num) => {\n    var pow = 1 + num / 2\n    pow = clamp(1.5, pow, 20)\n    var N = 255\n    var arr = new Float32Array(N)\n    for (var i = 0; i < N; i++) {\n        var x = 2 * (i / (N - 1)) - 1\n        if (x > 0) {\n            arr[i] = mix(0, 1, x, pow)\n        } else {\n            arr[i] = mix(0, -1, -x, pow)\n        }\n    }\n    return arr\n}\n\n\n\ncurveCreators.fat = (num) => {\n    var pow = 1 - num / 9\n    pow = clamp(0.05, pow, 0.95)\n    var N = 255\n    var arr = new Float32Array(N)\n    for (var i = 0; i < N; i++) {\n        var x = 2 * (i / (N - 1)) - 1\n        if (x > 0) {\n            arr[i] = mix(0, 1, x, pow)\n        } else {\n            arr[i] = mix(0, -1, -x, pow)\n        }\n    }\n    return arr\n}\n\n\n\n\nfunction mix(a, b, t, pow) {\n    return a + (b - a) * Math.pow(t, pow)\n}\n\nfunction clamp(min, val, max) {\n    return (val < min) ? min : (val > max) ? max : val\n}\n\n\n\n\n","\nimport { createShaper } from './shapers'\nimport { getCache } from '../lib/contextCache'\n\nvar MODULE_NAME = 'bit-crusher'\n\n\n/*\n * \n * \n *      Creates a bit-crusher audio worklet\n *  \n *      * unfortunately complicated, because Worklets\n *      * returns a wave shaper if worklets aren't supported\n * \n *      expects program like: { type: 'crush-4' }\n *      can specify freq param: { type: 'crush-4-0.4' }\n * \n * \n*/\n\n\n\nexport function isCrusher(type) {\n    return (/^crush/i.test(type))\n}\n\n\nexport function createCrusher(ctx, type) {\n    initializeWorklet(ctx)\n\n    // params\n    var arr = type.split('-')\n    var depth = parseInt(arr[1])\n    var freq = parseFloat(arr[2]) || 0.2\n    if (depth === 0) depth = 1\n    if (!depth) depth = 5\n\n    // fallback if no worklets\n    var data = getCache(ctx)\n    if (data.crush_worklet_state !== 'ok') {\n        return createShaper(ctx, `shape-crush-${depth}`)\n    }\n\n    var node = new AudioWorkletNode(ctx, MODULE_NAME)\n    node.parameters.get('depth').value = depth\n    node.parameters.get('freq').value = freq\n    // window['MY_AUDIO_WORKLET'] = node\n    node['isWorklet'] = true\n    return node\n}\n\n\n// logic to init the AudioWorklet module, only once!\nexport function initializeWorklet(ctx) {\n    var data = getCache(ctx)\n    if (data.crush_worklet_state) return\n    data.crush_worklet_state = 'trying'\n    importWorkletModule(ctx, MODULE_NAME).then(res => {\n        data.crush_worklet_state = (res) ? 'ok' : 'ng'\n    })\n}\n\n\n\n\n\n\n/*\n * \n * \n * \n *              Bitcrusher audio worklet!\n *              Worklet code is sorta from:\n * https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Using_AudioWorklet\n * \n * \n * \n*/\n\n// this function exists only to get stringified\nfunction bitcrushClassContainer() {\n    // @ts-ignore\n    class BitcrushProcessor extends AudioWorkletProcessor {\n        constructor() {\n            super()\n            this.phase = 0\n            this.sample = 0\n        }\n        static get parameterDescriptors() {\n            return [\n                { name: 'depth', defaultValue: 5, minValue: 1, maxValue: 20 },\n                { name: 'freq', defaultValue: 0.2, minValue: 0.01, maxValue: 1 },\n            ]\n        }\n        process(inputs, outputs, parameters) {\n            var input = inputs[0]\n            var output = outputs[0]\n            var steps = parameters.depth[0]\n            var freq = parameters.freq[0]\n            var scale = steps + 0.4999\n            var invsteps = 1 / steps\n            var phase = this.phase\n            var sample = this.sample\n\n            for (var i = 0; i < input.length; i++) {\n                var channelIn = input[i]\n                var channelOut = output[i]\n                for (var j = 0; j < channelIn.length; j++) {\n                    phase += freq\n                    if (phase >= 1) {\n                        phase -= 1\n                        sample = Math.round(channelIn[j] * scale) * invsteps\n                    }\n                    channelOut[j] = sample\n                }\n            }\n            this.phase = phase\n            this.sample = sample\n            return true\n        }\n    }\n    // @ts-ignore\n    registerProcessor('MODULE_NAME', BitcrushProcessor)\n}\n\n\n\n\n/*\n * \n *      scaffolding to fake importing a module\n * \n*/\n\nasync function importWorkletModule(ctx, moduleName) {\n    if (!ctx.audioWorklet) return false\n    // stringified function with class and invocation\n    var moduleFnStr = bitcrushClassContainer.toString()\n        .replace('MODULE_NAME', moduleName)\n    var iifeStr = `(${moduleFnStr})()`\n    try {\n        // don't resume if given an offline context\n        if (!ctx.startRendering) await ctx.resume()\n        var blob = new Blob([iifeStr], {\n            type: 'application/javascript'\n        })\n        var url = URL.createObjectURL(blob)\n        await ctx.audioWorklet.addModule(url)\n    } catch (e) {\n        return false\n    }\n    return true\n}\n\n\n\n\n\n\n\n","\n\n/*\n * \n * \n *      Creates web audio nodes for biquad filter effects\n * \n * \n*/\n\n\nexport function isFilter(type) {\n    var head = type.substr(0, 2)\n    return !!filterTypes[head]\n}\n\n// create a filter node based on the input signal definition\nexport function createFilter(ctx, type) {\n    var filter = ctx.createBiquadFilter()\n    var head = type.substr(0, 2)\n    var longer = type.substr(0, 5)\n    filter.type = filterTypes[longer] || filterTypes[head] || 'allpass'\n    return filter\n}\n\n\n\n\n\n/*\n * \n *      known types / conformance\n * \n*/\n\n\nvar filterTypes = {\n    pe: 'peaking',\n    ba: 'bandpass',\n    no: 'notch',\n    al: 'allpass',\n    lo: 'lowpass',\n    hi: 'highpass',\n    lowsh: 'lowshelf',\n    highs: 'highshelf',\n}\n","\n\nimport { createCrusher, isCrusher } from './crusher'\nimport { createShaper, isShaper } from './shapers'\nimport { createFilter, isFilter } from './filters'\n\n\n/*\n * \n *      Builds node for a single effect program\n *      Current possible effect types:\n *              wave shaper\n *              biquad filter\n *              or bit-crusher\n * \n*/\n\n\nexport function createEffect(ctx, type) {\n\n    if (isCrusher(type)) return createCrusher(ctx, type)\n    if (isShaper(type)) return createShaper(ctx, type)\n    if (isFilter(type)) return createFilter(ctx, type)\n\n    return null\n}\n\n\n\n\n\n\n","\nvar DEBUG = 0\n\n\n\n/*\n * \n *      notes:\n *  works by storing an array of event data objects on the param\n *  note that each event's end time (t1) is what WebAudio cares about,\n *      so: events cover the time span: (t0, t1]\n *  also note webaudio doesn't like two events at the same time \n *      (except: setValueAtTime SHOULD coincide with end of previous event)\n * \n*/\n\n\n\nexport default class Enveloper {\n\n    constructor(ctx) {\n        this.ctx = ctx\n        this.zeroRampTarget = 0.001\n    }\n\n\n    // one-time setup, will remove any existing envelope events\n    initParam(param, baseValue) {\n        param.cancelScheduledValues(0)\n        // tack internal data onto param object\n        param.__paramEnveloperEvents = [\n            new Event(HOLD, baseValue, baseValue, 0, 0),\n        ]\n        param.setValueAtTime(baseValue, 0)\n        debug('init:  param base set to', baseValue, 'time 0')\n    }\n\n\n\n    // starts a new envelope, canceling any subsequent events\n    // existing event for that time will be edited to end early\n    startEnvelope(param, time) {\n        var now = this.ctx.currentTime\n        if (!(time > now)) time = now\n        var events = param.__paramEnveloperEvents\n        var last = events[events.length - 1]\n        // prune events too old to affect the parameter\n        pruneEventsBefore(events, now)\n        // if nothing remains, or if envelope starts after \n        // last known event, just add a hold and exit\n        if (events.length === 0 || time > last.t1) {\n            var lastVal = last.v1\n            events.push(new Event(HOLD, lastVal, lastVal, 0, time))\n            param.setValueAtTime(lastVal, time)\n            debug('start:  fresh envelope, value', lastVal, ' from time', time)\n            return\n        }\n        // otherwise: envelope starts during an existing event\n        var curr = getEventActiveAtTime(events, time)\n        if (!curr) throw 'event list conformance bug, should not happen!'\n        // prune any event data after curr\n        events.length = events.indexOf(curr) + 1\n        // if env start coincides with curr end, then no new events to schedule\n        // cancel AFTER t1, so that its end event sticks around\n        if (time === curr.t1) {\n            param.cancelScheduledValues(time + 0.0001)\n            debug('start:  envelope begins: value', last.v1, 'from time', time)\n            return\n        }\n        // otherwise cancel from time exactly\n        param.cancelScheduledValues(time)\n        // edit curr's to end at correct time and value\n        var val = getValueDuringEvent(curr, time)\n        curr.v1 = val\n        curr.t1 = time\n        // and finally, reschedule its end event\n        debug('start:  envelope begins: value', val, 'from time', time)\n        if (curr.type === HOLD) {\n            param.setValueAtTime(val, time)\n            debug('--set value', val, 'time', time)\n        } else if (curr.type === RAMP_LINEAR) {\n            param.linearRampToValueAtTime(val, time)\n            debug('--ramp to', val, 'time', time)\n        } else if (curr.type === RAMP_EXPO) {\n            val = val || this.zeroRampTarget\n            param.exponentialRampToValueAtTime(val, time)\n            debug('--exp ramp to', val, 'time', time)\n        } else if (curr.type === SWEEP) {\n            param.setValueAtTime(val, time)\n            debug('--set value', val, 'time', time)\n        }\n    }\n\n\n    // adds a delay to the envelope, holding the previous value\n    addHold(param, duration) {\n        if (!(duration > 0)) return\n        var events = param.__paramEnveloperEvents\n        var last = events[events.length - 1]\n        if (last.t1 === Infinity) {\n            // hold after an open sweep is a special case, treat it like a new envelope\n            var breakTime = last.t0 + duration\n            debug('hold:   during sweep, start new envelope from time:', breakTime)\n            this.startEnvelope(param, breakTime)\n        } else {\n            var v0 = last.v1\n            var t0 = last.t1\n            var v1 = v0\n            var t1 = t0 + duration\n            events.push(new Event(HOLD, v0, v1, t0, t1))\n            param.setValueAtTime(v1, t1)\n            debug('hold:   val', v1, 'until time', t1)\n        }\n    }\n\n\n    // adds a ramp up to the specified target\n    addRamp(param, duration, target, exponential) {\n        // web audio API doesn't like coincident events\n        var minDur = 0.0001\n        if (!(duration > minDur)) duration = minDur\n        var events = param.__paramEnveloperEvents\n        var last = events[events.length - 1]\n        var v0 = last.v1\n        var t0 = last.t1\n        if (last.t1 === Infinity) throw 'Error - change scheduled after a sweep with infinite duration'\n        var v1 = target\n        var t1 = t0 + duration\n        if (exponential) {\n            v0 = v0 || this.zeroRampTarget\n            v1 = v1 || this.zeroRampTarget\n            param.exponentialRampToValueAtTime(v1, t1)\n        } else {\n            param.linearRampToValueAtTime(v1, t1)\n        }\n        var type = exponential ? RAMP_EXPO : RAMP_LINEAR\n        events.push(new Event(type, v0, v1, t0, t1))\n        debug('ramp:  to val', v1, 'time', t1, exponential ? 'exp' : 'linear')\n    }\n\n\n\n    // adds an exponential sweep towards a target\n    // for duration > 0, approaches (but will not reach) the target\n    // otherwise, extends the envelope forever, approaching the target\n    addSweep(param, duration, target, timeConstant) {\n        var events = param.__paramEnveloperEvents\n        var last = events[events.length - 1]\n        var v0 = last.v1\n        var t0 = last.t1\n        if (last.t1 === Infinity) throw 'Error - change scheduled after a sweep with infinite duration'\n        param.setTargetAtTime(target, t0, timeConstant)\n        var t1, v1\n        if (duration > 0) {\n            t1 = t0 + duration\n            v1 = calculateSweepValue(duration, v0, target, timeConstant)\n        } else {\n            t1 = Infinity\n            v1 = target\n        }\n        var ev = new Event(SWEEP, v0, v1, t0, t1)\n        ev.k = timeConstant\n        ev.tgt = target\n        events.push(ev)\n        debug('sweep: to target', target, 'const', timeConstant, 'from time', t0, 'to', t1)\n    }\n\n\n    // figure out the planned param value at the given time\n    getValueAtTime(param, time) {\n        var events = param.__paramEnveloperEvents\n        var ev = getEventActiveAtTime(events, time)\n        if (!ev) return events[events.length - 1].v1\n        return getValueDuringEvent(ev, time)\n    }\n\n\n}\n\n\n\n\n\n\n/*\n * \n *          Event list management\n * \n*/\n\n// event type enums\nvar HOLD = 1\nvar SWEEP = 2\nvar RAMP_LINEAR = 3\nvar RAMP_EXPO = 4\n\nfunction Event(type, v0, v1, t0, t1) {\n    this.type = type\n    this.v0 = +v0\n    this.v1 = +v1\n    this.t0 = +t0\n    this.t1 = +t1\n    this.k = 0.1\n    this.tgt = 0.1\n}\n\n\nfunction pruneEventsBefore(events, time) {\n    // prune events that END BEFORE specified time\n    while (events.length > 0 && events[0].t1 < time) {\n        events.shift()\n    }\n}\n\nfunction getEventActiveAtTime(events, t) {\n    for (var i = 0; i < events.length; i++) {\n        if (t > events[i].t1) continue\n        return events[i]\n    }\n    return null\n}\n\nfunction getValueDuringEvent(ev, time) {\n    if (ev.type === HOLD) return ev.v0\n    var dt = time - ev.t0\n    if (ev.type === RAMP_LINEAR) {\n        return calculateLinearRampValue(dt, ev.v0, ev.v1, ev.t1 - ev.t0)\n    }\n    if (ev.type === RAMP_EXPO) {\n        return calculateExpoRampValue(dt, ev.v0, ev.v1, ev.t1 - ev.t0)\n    }\n    if (ev.type === SWEEP) {\n        return calculateSweepValue(dt, ev.v0, ev.tgt, ev.k)\n    }\n}\n\n\n\n\n\n\n\n/*\n * \n *          util\n * \n*/\n\nfunction calculateSweepValue(dt, v0, v1, timeConst) {\n    return v1 + (v0 - v1) * Math.exp(-dt / timeConst)\n}\n\nfunction calculateLinearRampValue(dt, v0, v1, duration) {\n    return v0 + (v1 - v0) * dt / duration\n}\n\nfunction calculateExpoRampValue(dt, v0, v1, duration) {\n    return v0 * Math.pow(v1 / v0, dt / duration)\n}\n\n\n\n\n\n\n// debuggin'\nvar debug = (DEBUG) ? function () {\n    console.log.apply(console, Array.prototype.slice.apply(arguments).map(v => {\n        return (typeof v === 'number') ? Math.round(v * 10000) / 10000 : v\n    }))\n} : () => { }\n","\nimport { buildSources } from './sources'\nimport { getCache } from './contextCache'\nimport Enveloper from 'param-enveloper'\n// import Enveloper from '../../../param-enveloper'\n\n\nvar DEBUG = 0\nvar MIN_ATTACK_RAMP = 0.0001\n\n\n\n/*\n * \n *\n *      outer logic to conform inputs and map them to implementations below\n * \n * \n*/\n\n\nexport function applyParam(ctx, param, note, freq, time, prog, type, target, needsEnv) {\n    debug('start')\n    debug('PARAM: ', type, 'time', time, 'needsEnv=' + needsEnv, 'now', ctx.currentTime)\n\n    var data = getCache(ctx)\n    if (!data.paramEnveloper) data.paramEnveloper = new Enveloper(ctx)\n    var enveloper = data.paramEnveloper\n\n    // defunctionify, and handle easy case where prog is a number literal\n    if (typeof prog === 'function') prog = prog()\n    if (isNum(prog) && !needsEnv) {\n        param.setValueAtTime(prog, 0)\n        return\n    }\n    // otherwise arrayify\n    var progList = (Array.isArray(prog)) ? prog : [prog]\n\n    // implicit values for parameter\n    var initValue = (type === 'freq') ? freq : 1\n    if (type === 'gain' && target === 'freq') initValue = freq\n\n    // info object that will carry through the process of scheduling param changes\n    var info = {\n        enveloper: enveloper,\n        type: type,\n        envStarted: false,\n        attackRampNeeded: !!needsEnv,\n        currValue: initValue,\n        startTime: time,\n        sweeping: false,\n        releaseTime: -1,\n        releaseTarget: (type === 'freq') ? -1 : 0,\n    }\n\n    // generate any sources needed for this param program\n    var sourceNode = buildSources(ctx, note, progList, freq, time, type)\n\n    // apply each (non-source) program in sequence, tracking state with info object\n    progList.forEach(prog => {\n        if (typeof prog === 'function') prog = prog()\n        if (isNum(prog)) prog = (type === 'freq') ?\n            { t: 0, f: prog } : { t: prog }\n        if (typeof prog !== 'object') return\n        if (prog.type) return // sources built already\n        applyProgram(param, prog, info, freq)\n    })\n\n    // apply an attack ramp if one was needed and not applied\n    if (info.attackRampNeeded) {\n        debug('- default attack ramp:')\n        var rampProg = { a: defaultValues.a }\n        applyProgram(param, rampProg, info, freq)\n    }\n\n    // add a release target if none exists\n    if (info.releaseTarget < 0) {\n        info.releaseTarget = info.currValue\n    }\n\n    if (!info.envStarted) {\n        debug('- no schedules, init to:', info.currValue)\n        enveloper.initParam(param, info.currValue)\n    }\n\n    // set release sweep if needed and not already applied\n    if (needsEnv && info.releaseTime < 0) {\n        info.releaseTime = defaultValues.r\n    }\n\n    // store info to note that will be needed when it gets released\n    if (info.releaseTime >= 0) {\n        note.envelopes.push({\n            param: param,\n            releaseTime: info.releaseTime,\n            releaseTarget: info.releaseTarget,\n            rootEnvelope: !!needsEnv,\n        })\n        debug('- stored release:', info.releaseTime, 'target', info.releaseTarget)\n    }\n\n    // store base-level frequency params for later bending, maybe\n    if (type === 'freq' && (target === 'root' || target === 'freq')) {\n        var mult = info.currValue / freq\n        if (mult !== 0) note.bendables.push({ param, mult })\n    }\n\n    // done, return the output of any source nodes created\n    info = null\n    debug('end')\n    return sourceNode\n}\n\n\n\n// helpers\nfunction isNum(v) {\n    if (typeof v !== 'number') return false\n    return !isNaN(v)\n}\n\nfunction conformEnvProperty(val, def, canBeNeg, aliasVal) {\n    if (typeof aliasVal !== 'undefined') val = aliasVal\n    if (typeof val === 'function') val = val()\n    if (!isNum(val)) return def\n    if (canBeNeg) return val\n    return (val < 0) ? def : val\n}\n\n\n\n\n\n\n\n\n\n/*\n * \n * \n *      apply a single program element to a param\n * \n * \n*/\n\n\nfunction applyProgram(param, prog, info, freq) {\n    // property conformance\n    var w = conformEnvProperty(prog.w, 0, false)\n    var a = conformEnvProperty(prog.a, -1, false)\n    var h = conformEnvProperty(prog.h, -1, false)\n    var s = conformEnvProperty(prog.s, 1, false, prog.p)\n    var x = conformEnvProperty(prog.x, 1, false) | 0\n    var k = conformEnvProperty(prog.k, 0, true)\n    if (a >= 0 && a < MIN_ATTACK_RAMP) a = MIN_ATTACK_RAMP\n\n\n    // force a non-zero ramp if it's needed and anything would come afterwards\n    if (info.attackRampNeeded && a < 0) {\n        var stuffLater = (h > 0) || (s !== 1)\n        if (stuffLater) a = defaultValues.a\n    }\n\n    // baseline starting value of the param\n    var paramVal = info.currValue || 1\n    if (k !== 0) {\n        var volKey = Math.pow(freq / 261.625, k)\n        paramVal *= volKey\n    }\n\n    // repeats can't function without a wait value\n    if (w === 0) x = 1\n\n    // if we have a repeat and param change, but no ramp, imply a ramp\n    if (x > 1 && a < 0) {\n        if (t !== 1 || f !== 0) a = MIN_ATTACK_RAMP\n    }\n\n    // add all the necessary events, possibly multiple times\n    var paramTime = info.startTime\n\n    // rest of the variables\n    var t = conformEnvProperty(prog.t, 1, false)\n    var f = conformEnvProperty(prog.f, 0, true)\n    var d = conformEnvProperty(prog.d, -1, false, prog.q)\n    var r = conformEnvProperty(prog.r, -1, false)\n    var z = conformEnvProperty(prog.z, -1, false)\n    var dr = conformEnvProperty(prog.dr, -1, true)\n    if (dr >= 0) { d = r = dr }\n    if (d <= 0) d = defaultValues.d\n\n    // repeat loop for applying changes\n    var repeats = Math.max(x, 1)\n    for (var i = 0; i < repeats; i++) {\n\n        if (w > 0) {\n            initEnvIfNeeded(info, param, paramVal)\n            addHold(info, param, w)\n            paramTime += w\n            debug('- wait for', w)\n\n            // if t/f will modify param, but no ramp is needed, imply one\n            if ((t !== 1 || f !== 0) && (a < 0)) a = 0\n        }\n\n        // if attack ramp is coming, need to init param before t/f\n        if (a >= 0) initEnvIfNeeded(info, param, paramVal)\n\n        // update param value\n        if (i > 0) paramVal = info.enveloper.getValueAtTime(param, paramTime)\n        paramVal = paramVal * t + f\n\n        // ad-hoc special case - in repeats, make falling freqs reflect\n        var reflectAt = 80\n        if (info.type === 'freq' && paramVal < reflectAt && f < 0) {\n            paramVal = 2 * reflectAt - paramVal\n            f = -f\n        }\n\n        if (a >= 0) {\n            if (info.sweeping) addHold(info, param, 0)\n            info.enveloper.addRamp(param, a, paramVal)\n            info.attackRampNeeded = false\n            paramTime += a || 0\n            debug('- linear ramp to', paramVal, 'over', a)\n        }\n\n        if (h > 0) {\n            initEnvIfNeeded(info, param, paramVal)\n            addHold(info, param, h)\n            paramTime += h\n            debug('- wait for', h)\n        }\n\n        if (s !== 1) {\n            initEnvIfNeeded(info, param, paramVal)\n            paramVal *= s\n            if (info.sweeping) addHold(info, param, 0)\n            info.enveloper.addSweep(param, -1, paramVal, d)\n            info.sweeping = true\n            debug('- open sweep to', paramVal, 'const', d)\n        }\n    }\n\n    // store the value for next program\n    info.currValue = paramVal\n\n    // remember release values if specified\n    if (r >= 0) info.releaseTime = r\n    if (z >= 0) info.releaseTarget = info.currValue * z\n}\n\nfunction addHold(info, param, duration) {\n    info.enveloper.addHold(param, duration || 0)\n    info.sweeping = false\n}\n\nfunction initEnvIfNeeded(info, param, initialValue) {\n    if (info.envStarted) return\n    if (info.attackRampNeeded) initialValue = 0\n    info.enveloper.initParam(param, initialValue)\n    info.enveloper.startEnvelope(param, info.startTime)\n    info.envStarted = true\n    debug('- initted param:', initialValue, 'time', info.startTime)\n}\n\n\n\n\n\n\n\n\n\n\n\n/*\n * \n *      default values\n * \n*/\n\n\nvar defaultValues = {\n    // common\n    w: 0,           // delay before the envelope starts\n    t: 1,           // multiplies the param value\n    f: 0,           // adds to the param value\n    k: 0,           // volume keying\n\n    // envelope\n    a: 0.05,        // env attack\n    h: 0.0,         // env hold\n    d: 0.1,         // env decay\n    s: 1,           // env sustain\n    r: 0.1,         // env release\n    z: -1,          // env release target\n    x: 1,           // # of times to repeatedly apply the envelope\n\n    // aliases\n    // p -> same as s\n    // q -> same as d\n    // dr -> sets d+r to one value\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// debuggin'\nvar debug = (DEBUG) ? (s => {\n    var depth = 0\n    return function (s) {\n        if (s === 'start') { depth++; return }\n        if (s === 'end') { depth--; return }\n        var args = Array.prototype.slice.apply(arguments)\n        args.unshift(''.padEnd((depth - 1) * 4))\n        console.log.apply(console, args)\n    }\n})() : () => { }\n\n","\nimport { createSourceNode } from '../builders/sourceNodes'\nimport { createEffect } from '../builders/effects'\nimport { applyParam } from './params'\n\n\n\n/*\n * \n *      Builds all source + effects for a chunk of input program\n *          i.e. all program objects with a 'type' property\n * \n *      'source' means a node generating sound (e.g. oscillator, noise)\n *      'effect' means a filter/shaper/crusher\n *      if the input program has multiple sources/effects, this module will\n *          merge them and return a single output node\n *      Note: applies param programs to each node - this may create more sources!\n * \n *      Inputs:\n *          note - data object for the current prog/note\n *          prog - can be: object, [object], ()=>object, ()=>[object]\n *          target - root/freq/gain/Q\n *          needsEnv - source needs a gain envelope to avoid artifacts\n * \n*/\n\n\nexport function buildSources(ctx, note, program, freq, time, target) {\n\n    // initial conformance\n    var programList = conformProgList(program)\n\n    // run through input programs, chaining/merging any sources/effects created\n    var currInputs = []\n\n    for (var i = 0; i < programList.length; i++) {\n        var prog = programList[i]\n        if (typeof prog === 'function') prog = prog()\n        if (typeof prog === 'string') prog = { type: prog }\n        if (typeof prog !== 'object') continue\n        if (typeof prog.type === 'undefined') continue\n        var type = prog.type\n        if (typeof type === 'function') type = type()\n        if (!type) type = 'sine'\n\n        // prog must represent either an effect or a source\n        var effect = null\n        var node = null\n        effect = createEffect(ctx, type)\n        node = effect || createSourceNode(ctx, type)\n        if (node.start) node.start(time)\n        note.nodes.push(node)\n\n        // chain into a gain node if prog exists or gain envelope is required\n        var gainNode = null\n        var needsEnv = (!effect && target === 'root')\n        var gainNeeded = needsEnv || prog.gain || (!effect && target === 'freq')\n        if (gainNeeded) {\n            gainNode = ctx.createGain()\n            note.nodes.push(gainNode)\n        }\n\n        // apply all parameter programs\n        applyAllParameters(ctx, note, node, prog, freq, time, target, gainNode, needsEnv)\n\n        // create any effects, chaining node into them\n        if (!effect && prog.effect) {\n            var effList = conformProgList(prog.effect)\n            for (var j = 0; j < effList.length; j++) {\n                var effProg = effList[j]\n                if (typeof effProg === 'function') effProg = effProg()\n                if (typeof effProg === 'string') effProg = { type: effProg }\n                if (typeof effProg !== 'object') continue\n                var chainedEffect = createEffect(ctx, effProg.type)\n                if (!chainedEffect) continue\n\n                // effect parameters\n                applyAllParameters(ctx, note, chainedEffect, effProg, freq, time, target, null, false)\n\n                // insert into output chain\n                note.nodes.push(chainedEffect)\n                node.connect(chainedEffect)\n                node = chainedEffect\n            }\n        }\n\n        // if gain was made earlier, chain into it now that effects are done\n        if (gainNode) {\n            node.connect(gainNode)\n            node = gainNode\n        }\n\n        // finally update the output chain\n        if (effect) {\n            currInputs.forEach(input => input.connect(node))\n            currInputs = [node]\n        } else {\n            currInputs.push(node)\n        }\n    }\n\n    // exit case where no sources were defined\n    if (currInputs.length === 0) return null\n\n    // final resolve for output chain\n    if (currInputs.length === 1) return currInputs.pop()\n\n    var output = ctx.createGain()\n    note.nodes.push(output)\n    currInputs.forEach(input => input.connect(output))\n    return output\n}\n\nfunction conformProgList(prog) {\n    if (typeof prog === 'function') prog = prog()\n    return (Array.isArray(prog)) ? prog : [prog]\n}\n\n\n\n\n\n\n\n/*\n * \n *      consolidated logic to apply param programs to a node\n *      node is a source or effect, prog is the node's program\n *      if necessary, adds a gain node after the node in question\n * \n*/\n\nfunction applyAllParameters(ctx, note, node, prog, freq, time, target, gainNode, needsEnv) {\n\n    if (node.Q && prog.Q) {\n        var srcQ = applyParam(ctx, node.Q, note, freq, time, prog.Q, 'Q', target, false)\n        if (srcQ) srcQ.connect(node.Q)\n    }\n\n    // always apply a frequency if possible, even if no program\n    if (node.frequency || node.playbackRate) {\n        var freqParam = node.frequency || node.playbackRate\n        var freqValue = (node.playbackRate) ? freq / 440 : freq\n        var freqProg = prog.freq || {}\n        var srcF = applyParam(ctx, freqParam, note, freqValue, time, freqProg, 'freq', target, false)\n        if (srcF) srcF.connect(freqParam)\n\n    }\n\n    var gainParam = (gainNode) ? gainNode.gain : node.gain || null\n    if (gainParam) {\n        var srcG = applyParam(ctx, gainParam, note, freq, time, prog.gain, 'gain', target, needsEnv)\n        if (srcG) srcG.connect(gainParam)\n    }\n}\n\n\n\n\n\n","\nimport { buildSources } from './lib/sources'\nimport Enveloper from 'param-enveloper'\n// import Enveloper from '../../param-enveloper'\n\nexport default function SoundPlayer(ctx) {\n\n\n    /*\n     * \n     *      local state\n     * \n    */\n\n    var currentNotes = {}       // hash of note data objects keyed by id\n    var currentNoteIDs = []     // array of ids, newest to oldest\n\n    var enveloper = new Enveloper(ctx)\n\n\n\n    /*\n     * \n     * \n     *          API\n     * \n     * \n    */\n\n    this.maxVoices = 32\n\n\n    this.play = function (program, freq, vel, time, releaseTime, destNode) {\n        pruneEndedNotes()\n        enforceMaxVoices(this.maxVoices - 1)\n        var note = makeNote(program, freq, vel, time, destNode)\n        currentNoteIDs.push(note.id)\n        currentNotes[note.id] = note\n        if (releaseTime) releaseNote(note, releaseTime)\n        return note.id\n    }\n\n\n    this.bend = function (noteID, freq, timeConst, time) {\n        var note = currentNotes[noteID]\n        if (note) bend(note, freq, timeConst, time)\n    }\n\n\n    this.release = function (noteID, time) {\n        var note = currentNotes[noteID]\n        if (note) releaseNote(note, time)\n    }\n\n\n    this.isPlaying = function (noteID) {\n        return !!currentNotes[noteID]\n    }\n\n\n    this.releaseAll = function (time) {\n        currentNoteIDs.forEach(id => {\n            releaseNote(currentNotes[id], time)\n        })\n    }\n\n\n    this.dispose = function () {\n        enforceMaxVoices(0) // hard-disposes all current notes\n        currentNotes = null\n        currentNoteIDs = null\n        clearInterval(pruneInterval)\n    }\n\n\n\n\n\n\n\n\n\n\n\n    /*\n     * \n     * \n     *          other note lifecycle\n     * \n     * \n    */\n\n\n    function enforceMaxVoices(limit) {\n        // hard-dispose notes, oldest first\n        while (currentNoteIDs.length > limit) {\n            var noteID = currentNoteIDs.shift()\n            disposeNote(currentNotes[noteID])\n            delete currentNotes[noteID]\n        }\n    }\n\n\n    function pruneEndedNotes() {\n        var t = ctx.currentTime\n        for (var i = 0; i < currentNoteIDs.length; i++) {\n            var id = currentNoteIDs[i]\n            var note = currentNotes[id]\n            if (note.endTime === 0 || t < note.endTime) continue\n            disposeNote(note)\n            delete currentNotes[id]\n            currentNoteIDs.splice(i, 1)\n            i--\n        }\n    }\n\n\n    // occasionally prune even if nothing's happening\n    var pruneInterval = setInterval(pruneEndedNotes, 800)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /*\n     * \n     * \n     *          NOTE create / release / dispose\n     * \n     * \n    */\n\n\n    function Note(time) {\n        if (++_noteID > 9999) _noteID = 1\n        this.id = _noteID\n        this.time = +time\n        this.endTime = +0\n        // audio nodes and such\n        this.nodes = []\n        this.envelopes = []\n        this.bendables = []\n    }\n    var _noteID = 0\n\n\n\n\n\n\n    function makeNote(program, freq, vel, time, dest) {\n\n        var note = new Note(time)\n\n        // build all sources for the root-level program\n        var node = buildSources(ctx, note, program, freq, time, 'root')\n\n        // edge case when program contained no sources\n        if (!node) {\n            var prog = { type: 'sine' }\n            node = buildSources(ctx, note, prog, freq, time, 'root')\n        }\n\n        // output chain is finished\n        if (vel === 1) {\n            node.connect(dest)\n        } else {\n            var volume = ctx.createGain()\n            note.nodes.push(volume)\n            volume.gain.value = (vel < 1) ? vel * vel : vel\n            node.connect(volume)\n            volume.connect(dest)\n        }\n\n        return note\n    }\n\n\n\n\n\n\n    /*\n     * \n     *      BEND\n     *  hacking...\n     * \n    */\n\n    function bend(note, freq, constant, time) {\n        if (note.endTime > 0) return\n        note.bendables.forEach(obj => {\n            var val = freq * obj.mult\n            obj.param.cancelScheduledValues(time)\n            obj.param.setTargetAtTime(val, time, constant)\n        })\n    }\n\n\n    /*\n     * \n     *      RELEASE\n     *  set release envelopes if there are any, etc.\n     * \n    */\n\n    function releaseNote(note, time) {\n        if (note.endTime > 0) return\n        note.endTime = time\n\n        // note envelope data objs: { param, release, ... }\n        note.envelopes.forEach((env, i) => {\n            var R = env.releaseTime\n            if (!(R >= 0)) return\n            var param = env.param\n\n            enveloper.startEnvelope(param, time)\n            var tgt = env.releaseTarget || 0\n            enveloper.addSweep(param, -1, tgt, R)\n\n            if (env.rootEnvelope) {\n                // 4 timeConstants means ~2% of original value\n                var noteEnd = time + 4 * R\n                note.endTime = Math.max(note.endTime, noteEnd)\n            }\n        })\n    }\n\n\n\n    function disposeNote(note) {\n        while (note.nodes.length > 0) {\n            var node = note.nodes.pop()\n            if (node.stop) node.stop()\n            if (node.buffer) node.buffer = null\n            if (node.gain) node.gain.cancelScheduledValues(0)\n            if (node.frequency) node.frequency.cancelScheduledValues(0)\n            if (node.playbackRate) node.playbackRate.cancelScheduledValues(0)\n            if (node.Q) node.Q.cancelScheduledValues(0)\n            node.disconnect()\n            node = null\n        }\n        note.nodes = null\n        note.envelopes = null\n        note.bendables = null\n    }\n\n\n}\n\n\n\n","\n/*!\n * wasgen: a web audio sound generator\n * @url      github.com/fenomas/wasgen\n * @author   Andy Hall <andy@fenomas.com>\n * @license  ISC\n */\n\n\nimport SoundPlayer from './soundPlayer'\nimport { initializeWorklet } from './builders/crusher'\n\nimport packageData from '../package.json'\nvar version = packageData.version\n\n\n/*\n *\n *      WASGEN\n *  \n *      Root module just exposes the API and conforms inputs\n * \n*/\n\nexport default function Generator(\n    audioContext = null,\n    destination = null,\n    noCompressor = false,\n    silent = false) {\n\n    this.version = version\n    if (!silent) console.log(`wasgen     v${this.version}`)\n\n\n    /*\n     * \n     *      init settings and output chain\n     * \n    */\n\n    var ctx = audioContext ||\n        new (window.AudioContext || window['webkitAudioContext'])()\n    var player = new SoundPlayer(ctx)\n\n    var checkContext = () => {\n        if (ctx.startRendering) return // skip for offline contexts\n        if (ctx.state !== 'running') ctx.resume()\n        initializeWorklet(ctx)\n    }\n\n    var currDest = destination || ctx.destination\n\n\n    // when given offline context, init immediately\n    if (ctx.startRendering) initializeWorklet(ctx)\n\n\n\n\n\n\n\n    /*\n     * \n     *      Audio API\n     * \n    */\n\n    var soon = () => ctx.currentTime + 0.05\n\n    this.play = function (program, freq = 440, vel = 1, time = 0, releaseTime = 0, destNode = null) {\n        checkContext()\n        freq = freq || 440\n        vel = vel || 1\n        if (!(time > 0)) time = soon()\n        releaseTime = releaseTime || 0\n        destNode = destNode || compressor || currDest\n        var noteID = player.play(program, freq, vel, time, releaseTime, destNode)\n        return noteID\n    }\n\n    this.bend = function (noteID, freq = 440, timeConst = 0.1, time = 0) {\n        freq = freq || 440\n        timeConst = timeConst || 0.1\n        time = time || soon()\n        player.bend(noteID, freq, timeConst, time)\n    }\n\n    this.release = function (noteID, time = 0) {\n        time = time || soon()\n        player.release(noteID, time)\n    }\n\n    this.noteIsPlaying = function (noteID) {\n        return player.isPlaying(noteID)\n    }\n\n    this.releaseAll = function (time = 0) {\n        time = time || soon()\n        player.releaseAll(time)\n    }\n\n\n\n\n    /*\n     * \n     *      getter/setters\n     * \n    */\n\n    this.compressor = null\n\n    this.now = function () {\n        return ctx.currentTime\n    }\n\n    this.maxVoices = function (n = 32) {\n        if (n) player.maxVoices = n\n        return player.maxVoices\n    }\n\n    this.destination = function (dest) {\n        if (dest) {\n            currDest = dest\n            initCompressor()\n        }\n        return currDest\n    }\n\n    this.audioContext = function (context) {\n        if (context) {\n            this.dispose()\n            ctx = context\n            player = new SoundPlayer(ctx)\n            currDest = ctx.destination\n            initCompressor()\n        }\n        return ctx\n    }\n\n\n\n\n\n    /*\n     * \n     *      compressor in output chain, by default\n     * \n    */\n\n    var initCompressor = () => {\n        if (compressor) compressor.disconnect()\n        if (noCompressor) return\n        compressor = ctx.createDynamicsCompressor()\n        compressor.threshold.value = -24    // -24\n        compressor.knee.value = 25          // 30\n        compressor.ratio.value = 20         // 12\n        compressor.attack.value = 0.003     // 0.003\n        compressor.release.value = 0.25     // 0.25\n        compressor.connect(currDest)\n        this.compressor = compressor\n    }\n\n    var compressor = null\n    initCompressor()\n\n\n\n\n\n\n\n    /*\n     * \n     *      lifecycle\n     * \n    */\n\n    this.dispose = function () {\n        player.dispose()\n        player = null\n        if (compressor) compressor.disconnect()\n        compressor = null\n        currDest = null\n        ctx = null\n    }\n\n\n\n}\n\n\n\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass BinaryHeapStrategy {\r\n    constructor(options) {\r\n        this.comparator = options.comparator;\r\n        this.data = options.initialValues ? options.initialValues.slice(0) : [];\r\n        this._heapify();\r\n    }\r\n    _heapify() {\r\n        if (this.data.length > 0) {\r\n            for (let i = 0; i < this.data.length; i++) {\r\n                this._bubbleUp(i);\r\n            }\r\n        }\r\n    }\r\n    queue(value) {\r\n        this.data.push(value);\r\n        this._bubbleUp(this.data.length - 1);\r\n    }\r\n    dequeue() {\r\n        const ret = this.data[0];\r\n        const last = this.data.pop();\r\n        if (this.data.length > 0 && last !== undefined) {\r\n            this.data[0] = last;\r\n            this._bubbleDown(0);\r\n        }\r\n        return ret;\r\n    }\r\n    peek() {\r\n        return this.data[0];\r\n    }\r\n    clear() {\r\n        this.data.length = 0;\r\n    }\r\n    _bubbleUp(pos) {\r\n        while (pos > 0) {\r\n            const parent = (pos - 1) >>> 1;\r\n            if (this.comparator(this.data[pos], this.data[parent]) < 0) {\r\n                const x = this.data[parent];\r\n                this.data[parent] = this.data[pos];\r\n                this.data[pos] = x;\r\n                pos = parent;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    _bubbleDown(pos) {\r\n        let last = this.data.length - 1;\r\n        while (true) {\r\n            const left = (pos << 1) + 1;\r\n            const right = left + 1;\r\n            let minIndex = pos;\r\n            if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {\r\n                minIndex = left;\r\n            }\r\n            if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {\r\n                minIndex = right;\r\n            }\r\n            if (minIndex !== pos) {\r\n                const x = this.data[minIndex];\r\n                this.data[minIndex] = this.data[pos];\r\n                this.data[pos] = x;\r\n                pos = minIndex;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return void 0;\r\n    }\r\n}\r\nexports.default = BinaryHeapStrategy;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BinaryHeapStrategy_1 = require(\"./BinaryHeapStrategy\");\r\nclass PriorityQueue {\r\n    constructor(options) {\r\n        this._length = 0;\r\n        this._length = options.initialValues ? options.initialValues.length : 0;\r\n        this.strategy = new BinaryHeapStrategy_1.default(options);\r\n    }\r\n    get length() { return this._length; }\r\n    queue(value) {\r\n        this._length++;\r\n        this.strategy.queue(value);\r\n    }\r\n    dequeue() {\r\n        if (!this._length)\r\n            throw new Error(\"Empty queue\");\r\n        this._length--;\r\n        return this.strategy.dequeue();\r\n    }\r\n    peek() {\r\n        if (!this._length)\r\n            throw new Error(\"Empty queue\");\r\n        return this.strategy.peek();\r\n    }\r\n    clear() {\r\n        this._length = 0;\r\n        this.strategy.clear();\r\n    }\r\n}\r\nexports.default = PriorityQueue;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst PriorityQueue_1 = require(\"./src/PriorityQueue\");\r\nexports.default = PriorityQueue_1.default;\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pathfinder = void 0;\nconst ts_priority_queue_1 = require(\"ts-priority-queue\");\nconst wrapNode = (node, previous, f = 0, g = 0, open = true) => {\n    return { node, previous, f, g, open };\n};\nclass Pathfinder {\n    methods;\n    maxIterations = 1e6;\n    constructor(params = {}) {\n        this.methods = {\n            nodeToPrimitive: (node) => node,\n            getNeighbors: () => [],\n            getMoveCost: () => 1,\n            getHeuristic: () => 1,\n            ...params,\n        };\n    }\n    findPath(start, goal) {\n        const startKey = this.methods.nodeToPrimitive(start);\n        const goalKey = this.methods.nodeToPrimitive(goal);\n        const open = new ts_priority_queue_1.default({ comparator: (a, b) => a.f - b.f });\n        const visited = {};\n        const startNode = wrapNode(start, null, 0, 0, true);\n        open.queue(startNode);\n        visited[startKey] = startNode;\n        let ct = 0;\n        while (open.length > 0) {\n            if (ct++ > this.maxIterations)\n                throw new Error('Infinite loop!');\n            const curr = open.dequeue();\n            if (!curr.open)\n                continue;\n            const currKey = this.methods.nodeToPrimitive(curr.node);\n            if (currKey === goalKey)\n                break;\n            curr.open = false;\n            this.methods.getNeighbors(curr.node).forEach((neighbor) => {\n                const moveCost = this.methods.getMoveCost(curr.node, neighbor);\n                if (moveCost < 0)\n                    return;\n                const neighborKey = this.methods.nodeToPrimitive(neighbor);\n                const nnode = visited[neighborKey];\n                const cost = curr.g + moveCost;\n                if (nnode && nnode.g <= cost)\n                    return;\n                const h = this.methods.getHeuristic(neighbor, goal);\n                if (nnode) {\n                    nnode.open = true;\n                    nnode.g = cost;\n                    nnode.f = cost + h;\n                    nnode.previous = curr;\n                    open.queue(nnode);\n                }\n                else {\n                    const newnode = wrapNode(neighbor, curr, cost + h, cost, true);\n                    visited[neighborKey] = newnode;\n                    open.queue(newnode);\n                }\n            });\n        }\n        open.clear();\n        const end = visited[goalKey];\n        if (!end)\n            return [];\n        const path = [end.node];\n        let p = end;\n        while (p.previous) {\n            path.push(p.previous.node);\n            p = p.previous;\n        }\n        return path.reverse();\n    }\n}\nexports.Pathfinder = Pathfinder;\n","export const Piano1 = {\n  type: 'sine',\n  freq: { type: 'triangle', gain: { t: 3, a: 0.01, h: 0.01, d: 0.7, s: 0.1, r: 0.05, k: -1.2 } },\n  gain: { t: 0.4, a: 0.005, h: 0.01, d: 0.7, s: 0 },\n}\n\nexport const Piano2 = {\n  type: 'triangle',\n  freq: {\n    type: 'triangle',\n    freq: { t: 3 },\n    gain: { t: 4, a: 0.01, h: 0.01, d: 0.4, s: 0.1, r: 0.05, k: -1 },\n  },\n  gain: { t: 0.4, a: 0.005, h: 0.01, d: 0.7, s: 0 },\n}\n","export const midiToFreq = (midi: number) => {\n  return Math.pow(2, (midi - 69) / 12) * 440\n}\n","import { Pathfinder } from 'abstract-pathfinder'\nimport { Piano1, Piano2 } from './instruments'\nimport { setPathStr } from './Main'\nimport { midiToFreq } from './util'\n\nconst rand = (a = 0, b = 1) => (a + Math.random() * (b - a + 1)) | 0\nlet ct = 0\nconst major = [0, 2, 4, 5, 7, 9, 11]\nconst makeChord = (n = 0) => [n, n + 2, n + 4].map((n) => major[n % 7])\nconst beatDur = 0.4\nconst vel = 0.5\nconst inMajorScale = (n = 0) => major.includes(n % 12)\n\n// fixed 1564 chords\nexport const playChords = (gen: any) => {\n  const now = gen.now() + 0.05\n  const relTime = now + beatDur * 3\n  const prog = [1, 5, 6, 4]\n  const bases = [60, 48, 60, 60]\n  const notes = makeChord(prog[ct % 4] - 1).map((n) => n + bases[ct % 4])\n  notes.push(notes[0] - 12)\n  notes.forEach((note) => {\n    gen.play(Piano1, midiToFreq(note), vel, now, relTime)\n  })\n  ct = (ct + 1) % 4\n}\n\n/**\n *\n *\n *\n *    melody notes via pathfinding\n */\n\nconst finder = new Pathfinder<number>({\n  getNeighbors: (n) => [0, 0, 0, 0].map(() => n + rand(-3, 3)),\n  getHeuristic: (a, b) => 5 + Math.abs(a - b) + rand(0, 3),\n  getMoveCost: (a, b) => Math.abs(a - b) + rand(1, 2) + (inMajorScale(b) ? 1 : 2),\n})\nconsole.log('finder')\nlet note = 72\nexport const playNotes = (gen: any) => {\n  let tgt = note + rand(-6, 6)\n  if (tgt === note) tgt++\n  if (!inMajorScale(tgt)) tgt++\n  if (Math.abs(tgt - note) > 8) tgt += tgt > note ? -12 : 12\n\n  const path = finder.findPath(note, tgt)\n  setPathStr(`[${path.join(', ')}]`)\n\n  let noteDur = beatDur * 2\n  if (path.length > 2) noteDur /= 2\n  if (path.length > 4) noteDur /= 2\n  let t = gen.now() + 0.05\n  path.forEach((note, i) => {\n    gen.play(Piano2, midiToFreq(note), vel, t, t + noteDur)\n    t += noteDur\n  })\n  note = ((72 + tgt) / 2) | 0\n  if (!inMajorScale(note)) note++\n}\n","import { createSignal } from 'solid-js'\nimport Generator from 'wasgen'\nimport { playChords, playNotes } from './music'\n\nconst [gen, setGen] = createSignal<any>(null)\nconst [isPlaying, setPlaying] = createSignal(false)\nexport const [pathStr, setPathStr] = createSignal('')\n\nconst intervals: any[] = []\n\nconst setupMusic = () => {\n  if (!gen()) setGen(new Generator())\n  if (!isPlaying()) {\n    playChords(gen())\n    intervals.push(setInterval(() => playChords(gen()), 1600))\n    intervals.push(setInterval(() => playNotes(gen()), 1600))\n    setPlaying(true)\n  } else {\n    clearInterval(intervals.pop())\n    clearInterval(intervals.pop())\n    setPlaying(false)\n  }\n}\n\nexport const Main = () => {\n  return (\n    <div>\n      <button onclick={setupMusic}>{isPlaying() ? 'Stop' : 'Start'}</button>\n      <br />\n      <br />\n      <pre style={{ 'font-size': '200%' }}>Path: {pathStr()}</pre>\n    </div>\n  )\n}\n","import { render } from 'solid-js/web'\nimport { Main } from './music/Main'\n\nconst root = document.getElementById('root')\n\nif (import.meta.env.DEV && !(root instanceof HTMLElement)) {\n  throw new Error('Root element not found.')\n}\n\nrender(\n  () => (\n    <main>\n      <h2>A* Music Demo!</h2>\n      <Main />\n    </main>\n  ),\n  root!\n)\n"],"names":["equalFn","a","b","signalOptions","runEffects","runQueue","STALE","PENDING","UNOWNED","Owner","Transition","ExternalSourceConfig","Listener","Updates","Effects","ExecCount","createRoot","fn","detachedOwner","listener","owner","unowned","current","root","updateFn","untrack","cleanNode","runUpdates","createSignal","value","options","s","setter","writeSignal","readSignal","createRenderEffect","c","createComputation","updateComputation","updates","lookUpstream","sSlot","node","isComp","i","o","TransitionRunning","markDownstream","time","runComputation","nextValue","err","handleError","init","pure","state","runTop","ancestors","wait","res","completeUpdates","e","queue","ignore","source","index","obs","n","castError","createComponent","Comp","props","reconcileArrays","parentNode","bLength","aEnd","bEnd","aStart","bStart","after","map","sequence","t","$$EVENTS","render","code","element","disposer","dispose","insert","template","html","isImportNode","isSVG","create","delegateEvents","eventNames","document","l","name","eventHandler","parent","accessor","marker","initial","insertExpression","key","oriTarget","oriCurrentTarget","retarget","handleNode","handler","data","walkUpTree","path","unwrapArray","multi","cleanChildren","v","array","currentArray","normalizeIncomingArray","appendNodes","normalized","unwrap","dynamic","len","item","prev","replacement","inserted","el","isParent","caches","getCache","ctx","createSourceNode","type","createWave","createPulse","createNoise","createOscillator","osc","oscillatorTypes","duty","shaper","makePulseCurve","N","curves","curve","cutoff","getPeriodicWave","cachedWaves","imag","real","num","cachedNoise","src","noiseType","noiseTypes","createNoiseBuffer","noiseLen","blen","buffer","makeWhiteNoise","makeBrownNoise","makePinkNoise","makeMetallicNoise","b0","b1","b2","b3","b4","b5","b6","max","white","hash","j","peak","addHarmonics","r1","r2","scale","posScale","phase1","phase2","pos","fastSin","lookups","mult","isShaper","createShaper","arr","curveType","numArg","curveCreators","cachekey","curveCache","clamp","x","ct","depth","steps","pow","mix","min","val","MODULE_NAME","isCrusher","createCrusher","initializeWorklet","freq","importWorkletModule","bitcrushClassContainer","BitcrushProcessor","inputs","outputs","parameters","input","output","invsteps","phase","sample","channelIn","channelOut","moduleName","moduleFnStr","iifeStr","blob","url","isFilter","head","filterTypes","createFilter","filter","longer","createEffect","Enveloper","param","baseValue","Event","HOLD","now","events","last","pruneEventsBefore","lastVal","curr","getEventActiveAtTime","debug","getValueDuringEvent","RAMP_LINEAR","RAMP_EXPO","SWEEP","duration","breakTime","v0","t0","v1","t1","target","exponential","minDur","timeConstant","calculateSweepValue","ev","dt","calculateLinearRampValue","calculateExpoRampValue","timeConst","MIN_ATTACK_RAMP","applyParam","note","prog","needsEnv","enveloper","isNum","progList","initValue","info","sourceNode","buildSources","applyProgram","rampProg","defaultValues","conformEnvProperty","def","canBeNeg","aliasVal","w","h","k","stuffLater","paramVal","volKey","f","paramTime","d","r","z","dr","repeats","initEnvIfNeeded","addHold","reflectAt","initialValue","program","programList","conformProgList","currInputs","effect","gainNode","gainNeeded","applyAllParameters","effList","effProg","chainedEffect","srcQ","freqParam","freqValue","freqProg","srcF","gainParam","srcG","SoundPlayer","currentNotes","currentNoteIDs","vel","releaseTime","destNode","pruneEndedNotes","enforceMaxVoices","makeNote","releaseNote","noteID","bend","id","pruneInterval","limit","disposeNote","Note","_noteID","dest","volume","constant","obj","env","R","tgt","noteEnd","version","packageData","Generator","audioContext","destination","noCompressor","silent","player","checkContext","currDest","soon","compressor","initCompressor","context","BinaryHeapStrategy_1","BinaryHeapStrategy","ret","left","right","minIndex","PriorityQueue_1","require$$0","PriorityQueue","tsPriorityQueue","dist","Pathfinder_1","ts_priority_queue_1","wrapNode","previous","g","open","Pathfinder","params","start","goal","startKey","goalKey","visited","startNode","neighbor","moveCost","neighborKey","nnode","cost","newnode","end","p","Piano1","Piano2","midiToFreq","midi","rand","major","makeChord","beatDur","inMajorScale","playChords","gen","relTime","bases","notes","finder","playNotes","setPathStr","noteDur","setGen","isPlaying","setPlaying","pathStr","intervals","setupMusic","pop","push","setInterval","Main","_el$","_tmpl$","_el$2","firstChild","_el$3","nextSibling","_el$4","_el$5","$$click","_$insert","style","setProperty","_$delegateEvents","getElementById","_$createComponent"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]}